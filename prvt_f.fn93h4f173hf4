https://fairyly.github.io/interview/

low async await ->done
https://juejin.cn/post/7007031572238958629
high reactive ref watch
https://juejin.cn/post/7199833312578535480
high nextTick&eventloop simple
https://ustbhuangyi.github.io/vue-analysis/v2/reactive/next-tick.html#vue-%E7%9A%84%E5%AE%9E%E7%8E%B0；
https://segmentfault.com/a/1190000012861862；
https://www.jianshu.com/p/bf63cd4af0a6；
[r1]https://juejin.cn/post/6885907453460873229；
[r2]https://zhuanlan.zhihu.com/p/584436324

high typeCheck ->done
https://www.cnblogs.com/onepixel/p/5126046.html

low gc
https://juejin.cn/post/6981588276356317214

high diff-trick-from-officail done
https://cn.vuejs.org/guide/extras/rendering-mechanism.html

high simple-webpack done
https://github.com/Cosen95/blog/issues/48

middle cycle-depend-module done
https://www.51cto.com/article/711910.html


```abap
<script>
    // 手写 async 和 await
    function createAsync(generationFn) {
        return function () {
            // 绑定参数，此时 generator 不会执行，直到第一个 next 被调用
            const gen=generationFn.apply(this,arguments);
            return new Promise((resolve, reject)=>{
                // 尝试调用 next 的函数
                function go(key, arg) { // key 在本例中只会是 'next'
                    let res;
                    try {
                        res=gen[key](arg);  // 调用 gen 的 next 函数，并传入 arg
                    } catch (error) {
                        reject(error);   // 如果存在错误则返回
                    }

                    const {value, done} = res; // 成功调用 next，结构获取结果
                    if(done) {
                        resolve(value);  // 如果已经 next 到最后一步，则 resolve，调取 then
                    }
                    else {
                        value.then(val=>go('next', val));    // 否则 go 下一个 next
                    }
                }
                go('next'); // 开始调用 next，会自动调用 next 调用直到 done
            });
        }
    }

    // 使用例：fn 需要是 Promise，这和 await 是一样的
    function fn(nums) {
        return new Promise(resolve => {
            setTimeout(() => {
            resolve(nums * 2)
            }, 1000)
        })
    }

    function* gen() {
        const num1 = yield fn(1)
        console.log(num1) // 2
        const num2 = yield fn(num1)
        console.log(num2) // 4
        const num3 = yield fn(num2)
        console.log(num3) // 8
        return num3
    }

    const genToAsync = createAsync(gen)
    const asyncRes = genToAsync()
    console.log(asyncRes) // Promise
    asyncRes.then(res => console.log(res)) // 8
</script>
```

Dom更新在微任务队列清空之后，宏任务队列开始之前，但并不是每一个循环都会更新，它会受到刷新率的限制。

compiler过程
转换当前文件为AST->收集当前文件依赖加入全局数组1->将当前文件AST转为JS代码加入全局数组2->设置当前文件为全局数组1的下一个->回第一步；
