# JS运行原理之字节码、解释器
参考资料：
https://zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E7%A0%81
https://segmentfault.com/a/1190000040361065/en
很多国内的blog都讲不清楚，看维基百科，看国外的帖子一下就明了了。
JS引擎是一般是的：JS引擎会将JS翻译成字节码，经由解释器将其转换为机器码运行。
那么什么是字节码，解释器？
首先说解释器，像C++这种语言，由编译器转换为机器码后运行；而JS，是由解释器转换为机器码运行。它们之间不同的是，C++要先被编译器全部转换成机器语言，变为一个存储了机器码的.exe文件，再用计算机直接执行它，是全量编译的；而JS是边被解释器读入边被转换为机器码执行，也就是增量解释。
再说字节码？JS引擎其实会先把JS转换为字节码，再交给解释器执行，为什么不一步到位直接转换为机器码？这其实是一个优化问题，解释器这种边读入边执行的导致其过程是没有记忆的，也就是调用同一个函数，每次都要重新解释，而解释这步其实相当耗时，浪费了大量时间。开发人员也很快意识到了这个问题，于是便做了优化————惰性编译，全局作用域代码先被编译为机器码并缓存，局部作用域代码还是运行时解释。但是，JS转换为机器码后占用的空间会增加（每个语句的信息量更小了，需要更多的语句），这其实是非常消耗内存的，随着代码量越来越大，被缓存的机器码越来越多，内存就吃不消了。于是，开发人员便发明了一种JS和机器码的中间形式————字节码，它占用的空间比机器码更小，于是被缓存的对象从机器码换成了字节码，而解释字节码很快，“JS->字节码->机器码”的速度并不比“JS->机器码”慢多少，所以是个不错的解决方案。

## 优化
上面我们说到：“调用同一个函数，每次都要重新解释”，其实JS引擎考虑了这一点，运用了很多先进的技术去优化解释步骤，比如“调用同一个函数”的次数很多时，也会将其缓存为机器码（或者缓存字节码，这里没找到详细资料说到底是什么样的，可能只有看源码才能知道，而且不同JS引擎的原理差异其实很大，缓存的对象、方式都有区别）。
